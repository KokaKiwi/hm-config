From 0ebce9bff5eda75fec6344d92fac3db7547a10ba Mon Sep 17 00:00:00 2001
From: KokaKiwi <kokakiwi+git@kokakiwi.net>
Date: Mon, 7 Oct 2024 11:17:11 +0200
Subject: [PATCH 2/4] PR#4801: podman: init module

Squashed commit of the following:

commit 6aa79fd47e5d657257ebc4756dd2fdbe3aadabe8
Author: Nicholas Hassan <nick@hassan.host>
Date:   Wed Oct 2 22:33:04 2024 +0930

    podman: map basic network options

    Provides some of the basic network options from quadlets as attribute options directly on the network. Remaining options are configured with "extraNetworkConfig"

    Signed-off-by: Nicholas Hassan <nick@hassan.host>

commit 18c7777436820265a3a3941af12bebf0a8db202d
Author: Nicholas Hassan <nick@hassan.host>
Date:   Sun Aug 25 17:01:00 2024 +0930

    podman: fix network unit newuidmap errors

    newuidmap with setuid needs to be in PATH for podman, so adding common
    places it can be found

    Signed-off-by: Nicholas Hassan <nick@hassan.host>

commit c5d92ae17205f406e88b0eb1b15007ba6bebf631
Author: Nicholas Hassan <nick@hassan.host>
Date:   Sun Aug 18 13:52:28 2024 +0930

    podman: fix incomplete linux platform guards

    Imported modules which defined home config options were missing linux platform checks

    Signed-off-by: Nicholas Hassan <nick@hassan.host>

commit 2023e7df9caecc50be0ee4de665ba24074680563
Author: Nicholas Hassan <nick@hassan.host>
Date:   Wed Aug 14 17:21:19 2024 +0930

    podman: fix networkMode duplication

    supplying networkMode options have a bunch of rules around them - for the meantime, treat networkMode and lists of bridge networks seperately.

commit 774b25bf54cadcca28df652df110ec0f61990634
Author: Nicholas Hassan <nick@hassan.host>
Date:   Tue Aug 13 17:28:46 2024 +0930

    podman: update assertions

    Add network name assertions and prevent changing container service name to prevent foot-gunning when the activation script diffs the running resources against the manifest.

    Signed-off-by: Nicholas Hassan <nick@hassan.host>

commit b49a75df3f8d6e9dd6827a6e546df8c9a165352e
Author: Nicholas Hassan <nick@hassan.host>
Date:   Fri Dec 22 10:54:18 2023 +1030

    podman: add new module 'podman'

    Adds a new Podman module for creating user containers and networks as
    systemd services. These are installed to the user's XDG_CONFIG/systemd/user directory.

    Signed-off-by: Nicholas Hassan <nick@hassan.host>
---
 modules/lib/maintainers.nix                   |  10 +
 modules/modules.nix                           |   1 +
 modules/services/podman-linux/containers.nix  | 411 ++++++++++++++++++
 modules/services/podman-linux/default.nix     |  14 +
 .../services/podman-linux/install-quadlet.nix | 182 ++++++++
 modules/services/podman-linux/networks.nix    | 111 +++++
 modules/services/podman-linux/options.nix     |  42 ++
 modules/services/podman-linux/podman-lib.nix  | 101 +++++
 modules/services/podman-linux/services.nix    |  54 +++
 tests/default.nix                             |   1 +
 .../services/podman-linux/container.nix       |  70 +++
 .../modules/services/podman-linux/default.nix |   5 +
 .../services/podman-linux/manifest.nix        |  63 +++
 .../modules/services/podman-linux/network.nix |  39 ++
 14 files changed, 1104 insertions(+)
 create mode 100644 modules/services/podman-linux/containers.nix
 create mode 100644 modules/services/podman-linux/default.nix
 create mode 100644 modules/services/podman-linux/install-quadlet.nix
 create mode 100644 modules/services/podman-linux/networks.nix
 create mode 100644 modules/services/podman-linux/options.nix
 create mode 100644 modules/services/podman-linux/podman-lib.nix
 create mode 100644 modules/services/podman-linux/services.nix
 create mode 100644 tests/modules/services/podman-linux/container.nix
 create mode 100644 tests/modules/services/podman-linux/default.nix
 create mode 100644 tests/modules/services/podman-linux/manifest.nix
 create mode 100644 tests/modules/services/podman-linux/network.nix

diff --git a/modules/lib/maintainers.nix b/modules/lib/maintainers.nix
index 5916024b..51b1b7d9 100644
--- a/modules/lib/maintainers.nix
+++ b/modules/lib/maintainers.nix
@@ -288,6 +288,16 @@
     github = "NitroSniper";
     githubId = 44097331;
   };
+  n-hass = {
+    name = "Nicholas Hassan";
+    email = "nick@hassan.host";
+    github = "n-hass";
+    githubId = 72363381;
+    keys = [{
+      longkeyid = "rsa4096/0xFC95AB946A781EE7";
+      fingerprint = "FDEE 6116 DBA7 8840 7323  4466 A371 5973 2728 A6A6";
+    }];
+  };
   seylerius = {
     email = "sable@seyleri.us";
     name = "Sable Seyler";
diff --git a/modules/modules.nix b/modules/modules.nix
index 6050e980..2352fc7a 100644
--- a/modules/modules.nix
+++ b/modules/modules.nix
@@ -350,6 +350,7 @@ let
     ./services/plan9port.nix
     ./services/playerctld.nix
     ./services/plex-mpv-shim.nix
+    ./services/podman-linux
     ./services/polybar.nix
     ./services/poweralertd.nix
     ./services/psd.nix
diff --git a/modules/services/podman-linux/containers.nix b/modules/services/podman-linux/containers.nix
new file mode 100644
index 00000000..8cb79f8b
--- /dev/null
+++ b/modules/services/podman-linux/containers.nix
@@ -0,0 +1,411 @@
+{ config, lib, pkgs, ... }:
+
+with lib;
+
+let
+  podman-lib = import ./podman-lib.nix { inherit lib; };
+
+  createQuadletSource = name: containerDef:
+    let
+      ### Definitions
+      serviceName = name;
+      containerName = name; # Use the submodule name as the container name
+      mergedServiceConfig = podman-lib.serviceConfigDefaults
+        // containerDef.serviceConfig;
+      mergedUnitConfig = podman-lib.unitConfigDefaults
+        // containerDef.unitConfig;
+      ###
+
+      ### Helpers
+      ifNotNull = podman-lib.sourceHelpers.ifNotNull;
+      ifNotEmptyList = podman-lib.sourceHelpers.ifNotEmptyList;
+      ifNotEmptySet = podman-lib.sourceHelpers.ifNotEmptySet;
+      ###
+
+      ### Formatters
+      formatExtraConfig = podman-lib.formatExtraConfig;
+      formatPrimitiveValue = podman-lib.formatPrimitiveValue;
+
+      formatNetworkDependencies = networks:
+        let formatElement = network: "podman-${network}-network.service";
+        in concatStringsSep " " (map formatElement networks);
+
+      formatEnvironment = env:
+        if env != { } then
+          concatStringsSep " "
+          (mapAttrsToList (k: v: "${k}=${formatPrimitiveValue v}") env)
+        else
+          "";
+
+      formatPorts = ports:
+        if ports != [ ] then
+          concatStringsSep "\n" (map (port: "PublishPort=${port}") ports)
+        else
+          "";
+
+      formatVolumes = volumes:
+        if volumes != [ ] then
+          concatStringsSep "\n" (map (volume: "Volume=${volume}") volumes)
+        else
+          "";
+
+      formatDevices = devices:
+        if devices != [ ] then
+          concatStringsSep "\n" (map (device: "AddDevice=${device}") devices)
+        else
+          "";
+
+      formatCapabilities = action: capabilities:
+        if capabilities != [ ] then
+          concatStringsSep "\n"
+          (map (capability: "${action}Capability=${capability}") capabilities)
+        else
+          "";
+
+      formatLabels = labels:
+        if labels != [ ] then
+          concatStringsSep "\n" (map (label: "Label=${label}") labels)
+        else
+          "";
+
+      formatAutoUpdate = autoupdate:
+        if autoupdate == "registry" then
+          "AutoUpdate=registry"
+        else if autoupdate == "local" then
+          "AutoUpdate=local"
+        else
+          "";
+
+      # TODO: check this against networkMode option. IE, if 'host' there are no bridge networks, etc
+      formatBridgeNetworks = containerDef:
+        if containerDef.networks != [ ] then
+          "Network=${concatStringsSep "," containerDef.networks}"
+        else
+          "";
+
+      formatPodmanArgs = containerDef:
+        let
+          networkAliasArg = if containerDef.networkAlias != null then
+            "--network-alias ${containerDef.networkAlias}"
+          else
+            null;
+          entrypointArg = if containerDef.entrypoint != null then
+            "--entrypoint ${containerDef.entrypoint}"
+          else
+            null;
+          allArgs = [ networkAliasArg entrypointArg ]
+            ++ containerDef.extraOptions;
+        in if allArgs != [ ] && allArgs != [ "" ] then
+          "PodmanArgs=${
+            concatStringsSep " "
+            (filter (arg: arg != null && arg != "") allArgs)
+          }"
+        else
+          "";
+      ###
+    in ''
+      # Automatically generated by home-manager podman container configuration
+      # DO NOT EDIT THIS FILE DIRECTLY
+      #
+      # ${serviceName}.container
+      [Unit]
+      Description=${
+        if containerDef.description != null then
+          containerDef.description
+        else
+          "Service for container ${containerName}"
+      }
+      After=network.target ${formatNetworkDependencies containerDef.networks}
+      ${ifNotEmptyList containerDef.networks
+      "Requires=${formatNetworkDependencies containerDef.networks}"}
+      ${formatExtraConfig mergedUnitConfig}
+
+      [Container]
+      Label=nix.home-manager.managed=true
+      ContainerName=${containerName}
+      Image=${containerDef.image}
+      ${ifNotEmptySet containerDef.environment
+      "Environment=${formatEnvironment containerDef.environment}"}
+      ${ifNotNull containerDef.environmentFile
+      "EnvironmentFile=${containerDef.environmentFile}"}
+      ${ifNotNull containerDef.command "Exec=${containerDef.command}"}
+      ${ifNotNull containerDef.user
+      "User=${formatPrimitiveValue containerDef.user}"}
+      ${ifNotNull containerDef.userNS "UserNS=${containerDef.userNS}"}
+      ${ifNotNull containerDef.group
+      "Group=${formatPrimitiveValue containerDef.group}"}
+      ${ifNotEmptyList containerDef.ports (formatPorts containerDef.ports)}
+      ${ifNotNull containerDef.networkMode
+      "Network=${containerDef.networkMode}"}
+      ${formatBridgeNetworks containerDef}
+      ${ifNotNull containerDef.ip4 "IP=${containerDef.ip4}"}
+      ${ifNotNull containerDef.ip6 "IP6=${containerDef.ip6}"}
+      ${ifNotEmptyList containerDef.volumes
+      (formatVolumes containerDef.volumes)}
+      ${ifNotEmptyList containerDef.devices
+      (formatDevices containerDef.devices)}
+      ${formatAutoUpdate containerDef.autoupdate}
+      ${ifNotEmptyList containerDef.addCapabilities
+      (formatCapabilities "Add" containerDef.addCapabilities)}
+      ${ifNotEmptyList containerDef.dropCapabilities
+      (formatCapabilities "Drop" containerDef.dropCapabilities)}
+      ${ifNotEmptyList containerDef.labels (formatLabels containerDef.labels)}
+      ${formatPodmanArgs containerDef}
+      ${formatExtraConfig containerDef.extraContainerConfig}
+
+      [Service]
+      Environment="PATH=/run/wrappers/bin:/run/current-system/sw/bin:${config.home.homeDirectory}/.nix-profile/bin"
+      ${formatExtraConfig mergedServiceConfig}
+
+      [Install]
+      ${if containerDef.autostart then
+        "WantedBy=multi-user.target default.target"
+      else
+        ""}
+    '';
+
+  toQuadletInternal = name: containerDef:
+    let
+      allAssertions =
+        (podman-lib.buildConfigAsserts name containerDef.serviceConfig
+          podman-lib.serviceConfigTypeRules)
+        ++ (podman-lib.buildConfigAsserts name containerDef.unitConfig
+          podman-lib.unitConfigTypeRules);
+    in {
+      serviceName =
+        "podman-${name}"; # quadlet generater leaves systemd name as 'podman-<name>.service'
+      source =
+        podman-lib.removeBlankLines (createQuadletSource name containerDef);
+      resourceType = "container";
+      assertions = allAssertions;
+    };
+
+in let
+  # Define the container user type as the user interface
+  containerDefinitionType = types.submodule {
+    options = {
+      description = mkOption {
+        type = with types; nullOr str;
+        description = "The description of the container.";
+        default = null;
+      };
+
+      image = mkOption {
+        type = types.str;
+        description = "The container image.";
+      };
+
+      entrypoint = mkOption {
+        type = with types; nullOr str;
+        description = "The container entrypoint.";
+        default = null;
+      };
+
+      command = mkOption {
+        type = with types; nullOr str;
+        description = "The command to run after the container specification.";
+        default = null;
+      };
+
+      environment = mkOption {
+        type = podman-lib.primitiveAttrs;
+        description = "Environment variables to set in the container";
+        default = { };
+        example = literalMD ''
+          ```
+          environment = {
+            VAR1 = "0:100";
+            VAR2 = true;
+            VAR3 = 5;
+          };
+          ```
+        '';
+      };
+
+      environmentFile = mkOption {
+        type = with types; nullOr str;
+        default = null;
+        description =
+          "Path to a file containing environment variables to set in the container.";
+        example = literalMD ''
+          `environmentFile = "/etc/environment";`
+        '';
+      };
+
+      ports = mkOption {
+        type = with types; listOf str;
+        default = [ ];
+        description = "A mapping of ports between host and container";
+        example = literalMD ''
+          `ports = [ "8080:80" ];`
+        '';
+      };
+
+      user = mkOption {
+        type = with types; nullOr (oneOf [ str int ]);
+        default = null;
+        description = "The user ID inside the container.";
+      };
+
+      userNS = mkOption {
+        type = with types; nullOr str;
+        default = null;
+        description = "Use a user namespace for the container.";
+      };
+
+      group = mkOption {
+        type = with types; nullOr (oneOf [ str int ]);
+        default = null;
+        description = "The group ID inside the container.";
+      };
+
+      networkMode = mkOption {
+        type = with types; nullOr str;
+        default = null;
+        description = "The network mode for the container.";
+      };
+
+      networks = mkOption {
+        type = with types; listOf str;
+        default = [ ];
+        description =
+          "The networks to connect the container to. Best that these networks are defined with services.podman.networks";
+        example = literalMD ''
+          `networks = [ "mynet" ];`
+        '';
+      };
+
+      ip4 = mkOption {
+        type = with types; nullOr str;
+        default = null;
+        description = "Set an IPv4 address for the container.";
+      };
+
+      ip6 = mkOption {
+        type = with types; nullOr str;
+        default = null;
+        description = "Set an IPv6 address for the container.";
+      };
+
+      networkAlias = mkOption {
+        type = with types; nullOr str;
+        default = null;
+        description = "Set a network alias for the container.";
+      };
+
+      volumes = mkOption {
+        type = with types; listOf str;
+        default = [ ];
+        description = "The volumes to mount into the container.";
+        example = literalMD ''
+          ```
+          volumes = [
+            "/tmp:/tmp"
+            "/var/run/test.secret:/etc/secret:ro"
+          ];
+          ```
+        '';
+      };
+
+      devices = mkOption {
+        type = types.listOf types.str;
+        default = [ ];
+        description =
+          "The devices to mount into the container, in the format '/dev/<host>:/dev/<container>'.";
+      };
+
+      autoupdate = mkOption {
+        type = with types; enum [ "" "registry" "local" ];
+        default = "";
+        description = "The autoupdate policy for the container.";
+        example = literalMD ''
+          `autoupdate = "registry"`;
+        '';
+      };
+
+      autostart = mkOption {
+        type = types.bool;
+        default = true;
+        description =
+          "Whether to start the container on user login / boot (requires user lingering).";
+      };
+
+      addCapabilities = mkOption {
+        type = with types; listOf str;
+        default = [ ];
+        description = "The capabilities to add to the container.";
+      };
+
+      dropCapabilities = mkOption {
+        type = with types; listOf str;
+        default = [ ];
+        description = "The capabilities to drop from the container.";
+      };
+
+      labels = mkOption {
+        type = with types; listOf str;
+        default = [ ];
+        description = "The labels to apply to the container.";
+      };
+
+      extraOptions = mkOption {
+        type = with types; listOf str;
+        default = [ ];
+        description = "Extra options to pass to the podman run command.";
+      };
+
+      extraContainerConfig = mkOption {
+        type = podman-lib.primitiveAttrs;
+        default = { };
+        description = "Extra configuration, in Podman Quadlet format.";
+        example = literalMD ''
+          ```
+          extraContainerConfig = {
+            UIDMap = "0:1000:1";
+            ReadOnlyTmpfs = true;
+            EnvironmentFile = [ /etc/environment /root/.env];
+          };
+          ```
+        '';
+      };
+
+      serviceConfig = mkOption {
+        type = podman-lib.serviceConfigType;
+        default = { };
+        description =
+          "Configuration values for the systemd service for the container.";
+      };
+
+      unitConfig = mkOption {
+        type = podman-lib.unitConfigType;
+        default = { };
+        description =
+          "Configuration values for the systemd unit for the container.";
+      };
+
+    };
+  };
+
+in {
+
+  imports = [ ./options.nix ];
+
+  options.services.podman.containers = mkOption {
+    type = types.attrsOf containerDefinitionType;
+    default = { };
+    description = "Attribute set of container definitions.";
+  };
+
+  config = let
+    containerQuadlets =
+      mapAttrsToList toQuadletInternal config.services.podman.containers;
+  in mkIf pkgs.stdenv.isLinux {
+    internal.podman-quadlet-definitions = containerQuadlets;
+    assertions =
+      flatten (map (container: container.assertions) containerQuadlets);
+
+    # manifest file
+    home.file."${config.xdg.configHome}/podman/containers.manifest".text =
+      podman-lib.generateManifestText containerQuadlets;
+  };
+}
diff --git a/modules/services/podman-linux/default.nix b/modules/services/podman-linux/default.nix
new file mode 100644
index 00000000..3159426f
--- /dev/null
+++ b/modules/services/podman-linux/default.nix
@@ -0,0 +1,14 @@
+{ pkgs, lib, ... }:
+
+with lib;
+
+{
+  imports =
+    [ ./services.nix ./networks.nix ./containers.nix ./install-quadlet.nix ];
+
+  config = mkIf pkgs.stdenv.isLinux {
+    meta.maintainers = [ hm.maintainers.n-hass ];
+    assertions =
+      [ (hm.assertions.assertPlatform "podman" pkgs platforms.linux) ];
+  };
+}
diff --git a/modules/services/podman-linux/install-quadlet.nix b/modules/services/podman-linux/install-quadlet.nix
new file mode 100644
index 00000000..6a0827b3
--- /dev/null
+++ b/modules/services/podman-linux/install-quadlet.nix
@@ -0,0 +1,182 @@
+{ config, lib, pkgs, ... }:
+
+with lib;
+
+let
+  podman-lib = import ./podman-lib.nix { inherit lib; };
+
+  quadletActivationCleanupScript = ''
+    PATH=$PATH:${podman-lib.newuidmapPaths}
+
+    resourceManifest=()
+    # Define VERBOSE_ENABLED as a function
+    VERBOSE_ENABLED() {
+      if [[ -n "''${VERBOSE:-}" ]]; then
+        return 0
+      else
+        return 1
+      fi
+    }
+
+    # Function to fill resourceManifest from the manifest file
+    function loadManifest {
+      local manifestFile="$1"
+      VERBOSE_ENABLED && echo "Loading manifest from $manifestFile..."
+      IFS=$'\n' read -r -d "" -a resourceManifest <<< "$(cat "$manifestFile")" || true
+    }
+
+    function isResourceInManifest {
+      local resource="$1"
+      for manifestEntry in "''${resourceManifest[@]}"; do
+        if [ "$resource" = "$manifestEntry" ]; then
+          return 0  # Resource found in manifest
+        fi
+      done
+      return 1  # Resource not found in manifest
+    }
+
+    function removeContainer {
+      echo "Removing orphaned container: $1"
+      if [[ -n "''${DRY_RUN:-}" ]]; then
+        echo "Would run podman stop $1"
+        echo "Would run podman $resourceType rm -f $1"
+      else
+        ${config.services.podman.package}/bin/podman stop "$1"
+        ${config.services.podman.package}/bin/podman $resourceType rm -f "$1"
+      fi
+    }
+
+    function removeNetwork {
+      echo "Removing orphaned network: $1"
+      if [[ -n "''${DRY_RUN:-}" ]]; then
+        echo "Would run podman network rm $1"
+      else
+        if ! ${config.services.podman.package}/bin/podman network rm "$1"; then
+          echo "Failed to remove network $1. Is it still in use by a container?"
+          return 1
+        fi
+      fi
+    }
+
+    function cleanup {
+      local resourceType=$1
+      local manifestFile="${config.xdg.configHome}/podman/$2"
+      local extraListCommands="''${3:-}"
+      [[ $resourceType = "container" ]] && extraListCommands+=" -a"
+
+      VERBOSE_ENABLED && echo "Cleaning up ''${resourceType}s not in manifest..."
+
+      loadManifest "$manifestFile"
+
+      formatString="{{.Name}}"
+      [[ $resourceType = "container" ]] && formatString="{{.Names}}"
+
+      # Capture the output of the podman command to a variable
+      local listOutput=$(${config.services.podman.package}/bin/podman $resourceType ls $extraListCommands --filter 'label=nix.home-manager.managed=true' --format "$formatString")
+
+      IFS=$'\n' read -r -d "" -a podmanResources <<< "$listOutput" || true
+
+      # Check if the array is populated and iterate over it
+      if [ ''${#resourceManifest[@]} -eq 0 ]; then
+        VERBOSE_ENABLED && echo "No ''${resourceType}s available to process."
+      else
+        for resource in "''${podmanResources[@]}"; do
+            if ! isResourceInManifest "$resource"; then
+
+              [[ $resourceType = "container" ]] && removeContainer "$resource"
+              [[ $resourceType = "network" ]] && removeNetwork "$resource"
+
+            else
+              if VERBOSE_ENABLED; then
+                echo "Keeping managed $resourceType: $resource"
+              fi
+            fi
+          done
+      fi
+    }
+
+    # Cleanup containers
+    cleanup "container" "containers.manifest"
+
+    # Cleanup networks
+    cleanup "network" "networks.manifest"
+  '';
+
+  # derivation to build a single Podman quadlet, outputting its systemd unit files
+  buildPodmanQuadlet = quadlet:
+    pkgs.stdenv.mkDerivation {
+      name = "home-${quadlet.resourceType}-${quadlet.serviceName}";
+
+      buildInputs = [ config.services.podman.package ];
+
+      dontUnpack = true;
+
+      buildPhase = ''
+        mkdir $out
+        # Directory for the quadlet file
+        mkdir -p $out/quadlets
+        # Directory for systemd unit files
+        mkdir -p $out/units
+
+        # Write the quadlet file
+        echo -n "${quadlet.source}" > $out/quadlets/${quadlet.serviceName}.${quadlet.resourceType}
+
+        # Generate systemd unit file/s from the quadlet file
+        export QUADLET_UNIT_DIRS=$out/quadlets
+        ${config.services.podman.package}/lib/systemd/user-generators/podman-user-generator $out/units
+      '';
+
+      passthru = {
+        outPath = self.out;
+        quadletData = quadlet;
+      };
+    };
+
+  # Create a derivation for each quadlet spec
+  builtQuadlets =
+    map buildPodmanQuadlet config.internal.podman-quadlet-definitions;
+
+  accumulateUnitFiles = prefix: path: quadlet:
+    let
+      entries = builtins.readDir path;
+      processEntry = name: type:
+        let
+          newPath = "${path}/${name}";
+          newPrefix = prefix + (if prefix == "" then "" else "/") + name;
+        in if type == "directory" then
+          accumulateUnitFiles newPrefix newPath quadlet
+        else [{
+          key = newPrefix;
+          value = {
+            path = newPath;
+            parentQuadlet = quadlet;
+          };
+        }];
+    in flatten
+    (map (name: processEntry name (getAttr name entries)) (attrNames entries));
+
+  allUnitFiles = concatMap (builtQuadlet:
+    accumulateUnitFiles "" "${builtQuadlet.outPath}/units"
+    builtQuadlet.quadletData) builtQuadlets;
+
+  # we're doing this because the home-manager recursive file linking implementation can't
+  # merge from multiple sources. so we link each file explicitly, which is fine for all unique files
+  generateSystemdFileLinks = files:
+    listToAttrs (map (unitFile: {
+      name = "${config.xdg.configHome}/systemd/user/${unitFile.key}";
+      value = { source = unitFile.value.path; };
+    }) files);
+
+in {
+  imports = [ ./options.nix ];
+
+  config = mkIf pkgs.stdenv.isLinux {
+    home.file = generateSystemdFileLinks allUnitFiles;
+
+    # if the length of builtQuadlets is 0, then we don't need register the activation script
+    home.activation.podmanQuadletCleanup =
+      lib.mkIf (lib.length builtQuadlets >= 1)
+      (lib.hm.dag.entryAfter [ "reloadSystemd" ]
+        quadletActivationCleanupScript);
+  };
+}
diff --git a/modules/services/podman-linux/networks.nix b/modules/services/podman-linux/networks.nix
new file mode 100644
index 00000000..f2a2e914
--- /dev/null
+++ b/modules/services/podman-linux/networks.nix
@@ -0,0 +1,111 @@
+{ config, lib, pkgs, ... }:
+
+with lib;
+
+let
+  podman-lib = import ./podman-lib.nix { inherit lib; };
+
+  ifNotNull = podman-lib.sourceHelpers.ifNotNull;
+  ifNotEmptyList = podman-lib.sourceHelpers.ifNotEmptyList;
+  ifNotEmptySet = podman-lib.sourceHelpers.ifNotEmptySet;
+
+  createQuadletSource = name: networkDef: ''
+    # Automatically generated by home-manager for podman network configuration
+    # DO NOT EDIT THIS FILE DIRECTLY
+    #
+    # ${name}.network
+    [Network]
+    Label=nix.home-manager.managed=true
+    NetworkName=${name}
+    ${ifNotNull networkDef.driver "Driver=${networkDef.driver}"}
+    ${ifNotNull networkDef.subnet "Subnet=${networkDef.subnet}"}
+    ${ifNotNull networkDef.gateway "Gateway=${networkDef.gateway}"}
+    ${podman-lib.formatExtraConfig networkDef.extraNetworkConfig}
+
+    [Install]
+    WantedBy=multi-user.target default.target
+
+    [Service]
+    Environment=PATH=${podman-lib.newuidmapPaths}:${
+      makeBinPath [ pkgs.su pkgs.coreutils ]
+    }
+    ExecStartPre=${pkgs.bash}/bin/bash -c 'until ${config.services.podman.package}/bin/podman unshare ${pkgs.coreutils}/bin/true; do sleep 1; done'
+    TimeoutStartSec=15
+    RemainAfterExit=yes
+  '';
+
+  networkConfigAssertions = name: networkDef: {
+    NetworkName = with types; enum [ "" name ];
+  };
+
+  toQuadletInternal = name: networkDef: {
+    serviceName =
+      "podman-${name}"; # quadlet generater makes systemd name 'podman-<name>-network.service'
+    source = podman-lib.removeBlankLines (createQuadletSource name networkDef);
+    resourceType = "network";
+    assertions = podman-lib.buildConfigAsserts name networkDef
+      (networkConfigAssertions name networkDef);
+  };
+
+in {
+  options = let
+    networkDefinitionType = types.submodule {
+      options = {
+
+        driver = mkOption {
+          type = with types; nullOr str;
+          default = null;
+          description = "The network driver to use.";
+          example = "bridge";
+        };
+
+        subnet = mkOption {
+          type = with types; nullOr str;
+          default = null;
+          description = "The subnet to use for the network.";
+          example = "192.168.20.0/24";
+        };
+
+        gateway = mkOption {
+          type = with types; nullOr str;
+          default = null;
+          description = "The gateway IP to use for the network.";
+          example = "192.168.20.1";
+        };
+
+        extraNetworkConfig = mkOption {
+          type = podman-lib.primitiveAttrs;
+          default = { };
+          description =
+            "Extra configuration for the network, in Podman Quadlet format.";
+          example = literalMD ''
+            ```
+            extraNetworkConfig = {
+              IPv6 = true;
+              Options = "isolate=true";
+              PodmanArgs = [ "--dns=192.168.55.1" ];
+            };
+            ```
+          '';
+        };
+      };
+    };
+  in {
+    services.podman.networks = mkOption {
+      type = types.attrsOf networkDefinitionType;
+      default = { };
+      description = "Defines Podman network quadlet configurations.";
+    };
+  };
+
+  config = let
+    networkQuadlets =
+      mapAttrsToList toQuadletInternal config.services.podman.networks;
+  in mkIf pkgs.stdenv.isLinux {
+    internal.podman-quadlet-definitions = networkQuadlets;
+    assertions = flatten (map (network: network.assertions) networkQuadlets);
+
+    home.file."${config.xdg.configHome}/podman/networks.manifest".text =
+      podman-lib.generateManifestText networkQuadlets;
+  };
+}
diff --git a/modules/services/podman-linux/options.nix b/modules/services/podman-linux/options.nix
new file mode 100644
index 00000000..41e80bdb
--- /dev/null
+++ b/modules/services/podman-linux/options.nix
@@ -0,0 +1,42 @@
+{ lib, pkgs, ... }:
+
+let
+  # Define the systemd service type
+  quadletInternalType = lib.types.submodule {
+    options = {
+      serviceName = lib.mkOption {
+        type = lib.types.str;
+        description = "The name of the systemd service.";
+      };
+
+      resourceType = lib.mkOption {
+        type = lib.types.str;
+        default = "";
+        description = "The type of the podman Quadlet resource.";
+      };
+
+      source = lib.mkOption {
+        type = lib.types.str;
+        description = "The quadlet source file content.";
+      };
+
+      assertions = lib.mkOption {
+        type = with lib.types; listOf unspecified;
+        default = [ ];
+        description = "List of Nix type assertions.";
+      };
+    };
+  };
+in {
+  options.internal.podman-quadlet-definitions = lib.mkOption {
+    type = lib.types.listOf quadletInternalType;
+    default = { };
+    description = "List of quadlet source file content and service names.";
+  };
+
+  options.services.podman.package = lib.mkOption {
+    type = lib.types.package;
+    default = pkgs.podman;
+    description = "The podman package to use.";
+  };
+}
diff --git a/modules/services/podman-linux/podman-lib.nix b/modules/services/podman-linux/podman-lib.nix
new file mode 100644
index 00000000..71694c84
--- /dev/null
+++ b/modules/services/podman-linux/podman-lib.nix
@@ -0,0 +1,101 @@
+{ lib, ... }:
+
+with lib;
+
+let
+  primitive = with types; nullOr (oneOf [ bool int str path ]);
+  primitiveAttrs = with types; attrsOf (either primitive (listOf primitive));
+
+  formatPrimitiveValue = value:
+    if isBool value then
+      (if value then "true" else "false")
+    else if isList value then
+      concatStringsSep " " (map toString value)
+    else
+      toString value;
+in {
+  inherit primitive;
+  inherit primitiveAttrs;
+  inherit formatPrimitiveValue;
+
+  serviceConfigTypeRules = {
+    Restart = types.enum [ "no" "always" "on-failure" "unless-stopped" ];
+    TimeoutStopSec = types.int;
+  };
+  serviceConfigDefaults = {
+    Restart = "always";
+    TimeoutStopSec = 30;
+    ExecStartPre = null;
+  };
+  serviceConfigType = with types; attrsOf (either primitive (listOf primitive));
+
+  unitConfigTypeRules = { After = with types; nullOr (listOf str); };
+  unitConfigDefaults = { After = null; };
+  unitConfigType = with types; attrsOf (either primitive (listOf primitive));
+
+  buildConfigAsserts = quadletName: config: configTypeRules:
+    flatten (mapAttrsToList (name: value:
+      if hasAttr name configTypeRules then [{
+        assertion = configTypeRules.${name}.check value;
+        message = "in '${quadletName}' config. ${name}: '${
+            toString value
+          }' does not match expected type: ${
+            configTypeRules.${name}.description
+          }";
+      }] else
+        [ ]) config);
+
+  formatExtraConfig = extraConfig:
+    let nonNullConfig = filterAttrs (name: value: value != null) extraConfig;
+    in concatStringsSep "\n"
+    (mapAttrsToList (name: value: "${name}=${formatPrimitiveValue value}")
+      nonNullConfig);
+
+  # input is expecting a list of quadletInternalType with all the same resourceType
+  generateManifestText = quadlets:
+    let
+      # create a list of all unique quadlet.resourceType in quadlets
+      quadletTypes = unique (map (quadlet: quadlet.resourceType) quadlets);
+      # if quadletTypes is > 1, then all quadlets are not the same type
+      allQuadletsSameType = length quadletTypes <= 1;
+
+      # ensures the service name is formatted correctly to be easily read by the activation script and matches `podman <resource> ls` output
+      formatServiceName = quadlet:
+        let
+          # remove the podman- prefix from the service name string
+          strippedName =
+            builtins.replaceStrings [ "podman-" ] [ "" ] quadlet.serviceName;
+          # specific logic for writing the unit name goes here. It should be identical to what `podman <resource> ls` shows
+        in {
+          "container" = strippedName;
+          "network" = strippedName;
+        }."${quadlet.resourceType}";
+    in if allQuadletsSameType then ''
+      ${concatStringsSep "\n"
+      (map (quadlet: formatServiceName quadlet) quadlets)}
+    '' else
+      abort ''
+        All quadlets must be of the same type.
+        Quadlet types in this manifest: ${concatStringsSep ", " quadletTypes}'';
+
+  # podman requires setuid on newuidmad, so it cannot be provided by pkgs.shadow
+  # Including all possible locations in PATH for newuidmap is a workaround.
+  # NixOS provides a 'wrapped' variant at /run/wrappers/bin/newuidmap.
+  # Other distros must install the 'uidmap' package, ie for ubuntu: apt install uidmap.
+  # Extra paths are added to handle where distro package managers may put the uidmap binaries.
+  #
+  # Tracking for a potential solution: https://github.com/NixOS/nixpkgs/issues/138423
+  newuidmapPaths = "/run/wrappers/bin:/usr/bin:/bin:/usr/sbin:/sbin";
+
+  sourceHelpers = {
+    ifNotNull = condition: text: if condition != null then text else "";
+    ifNotEmptyList = list: text: if list != [ ] then text else "";
+    ifNotEmptySet = set: text: if set != { } then text else "";
+  };
+
+  removeBlankLines = text:
+    let
+      lines = splitString "\n" text;
+      nonEmptyLines = filter (line: line != "") lines;
+    in concatStringsSep "\n" nonEmptyLines;
+}
diff --git a/modules/services/podman-linux/services.nix b/modules/services/podman-linux/services.nix
new file mode 100644
index 00000000..223d3958
--- /dev/null
+++ b/modules/services/podman-linux/services.nix
@@ -0,0 +1,54 @@
+{ config, lib, pkgs, ... }:
+
+with lib;
+
+let cfg = config.services.podman;
+in {
+  options.services.podman = {
+    auto-update = {
+      enable = mkOption {
+        type = types.bool;
+        default = false;
+        description = "Automatically update the podman images.";
+      };
+
+      OnCalendar = mkOption {
+        type = types.str;
+        default = "Sun *-*-* 00:00";
+        description = "Systemd OnCalendar expression for the update";
+      };
+    };
+  };
+
+  config = mkIf pkgs.stdenv.isLinux (mkMerge [
+    (mkIf cfg.auto-update.enable {
+      systemd.user.services."podman-auto-update" = {
+        Unit = {
+          Description = "Podman auto-update service";
+          Documentation = "man:podman-auto-update(1)";
+          Wants = [ "network-online.target" ];
+          After = [ "network-online.target" ];
+        };
+        Service = {
+          Type = "oneshot";
+          Environment =
+            "PATH=/run/wrappers/bin:/run/current-system/sw/bin:${config.home.homeDirectory}/.nix-profile/bin";
+          ExecStart = "${pkgs.podman}/bin/podman auto-update";
+          ExecStartPost = "${pkgs.podman}/bin/podman image prune -f";
+          TimeoutStartSec = "300s";
+          TimeoutStopSec = "10s";
+        };
+      };
+
+      systemd.user.timers."podman-auto-update" = {
+        Unit = { Description = "Podman auto-update timer"; };
+        Timer = {
+          OnCalendar = cfg.auto-update.OnCalendar;
+          RandomizedDelaySec = 300;
+          Persistent = true;
+        };
+        Install = { WantedBy = [ "timers.target" ]; };
+      };
+    })
+  ]);
+}
diff --git a/tests/default.nix b/tests/default.nix
index 9c5479e6..d36077b2 100644
--- a/tests/default.nix
+++ b/tests/default.nix
@@ -268,6 +268,7 @@ in import nmtSrc {
     ./modules/services/pbgopy
     ./modules/services/picom
     ./modules/services/playerctld
+    ./modules/services/podman-linux
     ./modules/services/polybar
     ./modules/services/recoll
     ./modules/services/redshift-gammastep
diff --git a/tests/modules/services/podman-linux/container.nix b/tests/modules/services/podman-linux/container.nix
new file mode 100644
index 00000000..af8d4a29
--- /dev/null
+++ b/tests/modules/services/podman-linux/container.nix
@@ -0,0 +1,70 @@
+{ ... }:
+
+{
+  config = {
+    services.podman.containers."my-container" = {
+      description = "home-manager test";
+      autoupdate = "registry";
+      autostart = true;
+      image = "docker.io/alpine:latest";
+      entrypoint = "sleep 1000";
+      environment = {
+        "VAL_A" = "A";
+        "VAL_B" = 2;
+        "VAL_C" = false;
+      };
+      ports = [ "8080:80" ];
+      volumes = [ "/tmp:/tmp" ];
+      devices = [ "/dev/null:/dev/null" ];
+
+      networks = [ "mynet" ];
+      networkAlias = "test-alias";
+
+      extraOptions = [ "--security-opt=no-new-privileges" ];
+      extraContainerConfig = { ReadOnlyTmpfs = true; };
+      serviceConfig = { Restart = "on-failure"; };
+      unitConfig = { Before = [ "fake.target" ]; };
+    };
+
+    nmt.script = ''
+      configPath=home-files/.config/systemd/user
+      containerFile=$configPath/podman-my-container.service
+      assertFileExists $containerFile
+
+      assertFileContains $containerFile \
+        "my-container.container"
+      assertFileContains $containerFile \
+        "Description=home-manager test"
+      assertFileContains $containerFile \
+        "AutoUpdate=registry"
+      assertFileContains $containerFile \
+        "Image=docker.io/alpine:latest"
+      assertFileContains $containerFile \
+        "PodmanArgs=--network-alias test-alias --entrypoint sleep 1000 --security-opt=no-new-privileges"
+      assertFileContains $containerFile \
+        "Environment=VAL_A=A VAL_B=2 VAL_C=false"
+      assertFileContains $containerFile \
+        "PublishPort=8080:80"
+      assertFileContains $containerFile \
+        "Volume=/tmp:/tmp"
+      assertFileContains $containerFile \
+        "AddDevice=/dev/null:/dev/null"
+      assertFileContains $containerFile \
+        "Network=mynet"
+      assertFileContains $containerFile \
+        "Requires=podman-mynet-network.service"
+      assertFileContains $containerFile \
+        "After=network.target podman-mynet-network.service"
+      assertFileContains $containerFile \
+        "ReadOnlyTmpfs=true"
+      assertFileContains $containerFile \
+        "Restart=on-failure"
+      assertFileContains $containerFile \
+        "Before=fake.target"
+      assertFileContains $containerFile \
+        "WantedBy=multi-user.target default.target"
+      assertFileContains $containerFile \
+        "Label=nix.home-manager.managed=true"
+    '';
+  };
+}
diff --git a/tests/modules/services/podman-linux/default.nix b/tests/modules/services/podman-linux/default.nix
new file mode 100644
index 00000000..c8b12bbd
--- /dev/null
+++ b/tests/modules/services/podman-linux/default.nix
@@ -0,0 +1,5 @@
+{
+  podman-container = ./container.nix;
+  podman-network = ./network.nix;
+  podman-state-manifest = ./manifest.nix;
+}
diff --git a/tests/modules/services/podman-linux/manifest.nix b/tests/modules/services/podman-linux/manifest.nix
new file mode 100644
index 00000000..37ddaba5
--- /dev/null
+++ b/tests/modules/services/podman-linux/manifest.nix
@@ -0,0 +1,63 @@
+{ pkgs, ... }:
+
+{
+  config = {
+    services.podman.containers."my-container-1" = {
+      description = "home-manager test";
+      autoupdate = "registry";
+      autostart = true;
+      image = "docker.io/alpine:latest";
+      entrypoint = "sleep 1000";
+      environment = {
+        "VAL_A" = "A";
+        "VAL_B" = 2;
+        "VAL_C" = false;
+      };
+    };
+
+    services.podman.containers."my-container-2" = {
+      description = "home-manager test";
+      autoupdate = "registry";
+      autostart = true;
+      image = "docker.io/alpine:latest";
+      entrypoint = "sleep 1000";
+      environment = {
+        "VAL_A" = "B";
+        "VAL_B" = 3;
+        "VAL_C" = true;
+      };
+    };
+
+    services.podman.networks."mynet-1" = {
+      subnet = "192.168.1.0/24";
+      gateway = "192.168.1.1";
+    };
+    services.podman.networks."mynet-2" = {
+      subnet = "192.168.2.0/24";
+      gateway = "192.168.2.1";
+    };
+
+    nmt.script = ''
+      configPath=home-files/.config/podman
+      containerManifest=$configPath/containers.manifest
+      networkManifest=$configPath/networks.manifest
+
+      assertFileExists $containerManifest
+      assertFileExists $networkManifest
+
+      assertFileContent $containerManifest ${
+        pkgs.writeText "containers.expected" ''
+          my-container-1
+          my-container-2
+        ''
+      }
+
+      assertFileContent $networkManifest ${
+        pkgs.writeText "networks.expected" ''
+          mynet-1
+          mynet-2
+        ''
+      }
+    '';
+  };
+}
diff --git a/tests/modules/services/podman-linux/network.nix b/tests/modules/services/podman-linux/network.nix
new file mode 100644
index 00000000..844d016b
--- /dev/null
+++ b/tests/modules/services/podman-linux/network.nix
@@ -0,0 +1,39 @@
+{ ... }:
+
+{
+  config = {
+    services.podman.networks.mynet = {
+      subnet = "192.168.1.0/24";
+      gateway = "192.168.1.1";
+      extraNetworkConfig = {
+        Options = "isolate=true";
+        PodmanArgs = [ "--dns=192.168.55.1" "--log-level=debug" ];
+      };
+    };
+
+    nmt.script = ''
+      configPath=home-files/.config/systemd/user
+      networkFile=$configPath/podman-mynet-network.service
+      assertFileExists $networkFile
+
+      assertFileContains $networkFile \
+        "mynet.network"
+      assertFileContains $networkFile \
+        "Subnet=192.168.1.0/24"
+      assertFileContains $networkFile \
+        "Gateway=192.168.1.1"
+      assertFileContains $networkFile \
+        "PodmanArgs=--dns=192.168.55.1 --log-level=debug"
+      assertFileContains $networkFile \
+        "Options=isolate=true"
+      assertFileContains $networkFile \
+        "NetworkName=mynet"
+      assertFileContains $networkFile \
+        "WantedBy=multi-user.target default.target"
+      assertFileContains $networkFile \
+        "RemainAfterExit=yes"
+      assertFileContains $networkFile \
+        "Label=nix.home-manager.managed=true"
+    '';
+  };
+}
-- 
2.47.0

